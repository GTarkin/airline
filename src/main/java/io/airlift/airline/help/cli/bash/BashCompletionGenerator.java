package io.airlift.airline.help.cli.bash;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import io.airlift.airline.CompletionOptions;
import io.airlift.airline.help.AbstractGlobalUsageGenerator;
import io.airlift.airline.model.CommandGroupMetadata;
import io.airlift.airline.model.CommandMetadata;
import io.airlift.airline.model.GlobalMetadata;
import io.airlift.airline.model.OptionMetadata;

public class BashCompletionGenerator extends AbstractGlobalUsageGenerator {

    @Override
    public void usage(GlobalMetadata global, OutputStream output) throws IOException {
        Writer writer = new OutputStreamWriter(output);

        // Bash Header
        writer.append("#!/bin/bash\n\n");
        // TODO Add a Generated By comment

        // Helper functions
        writer.append("containsElement () {\n");
        writer.append("  # This function from http://stackoverflow.com/a/8574392/107591\n");
        writer.append("  local e\n");
        writer.append("  for e in \"${@:2}\"; do [[ \"$e\" == \"$1\" ]] && return 0; done\n");
        writer.append("  return 1\n");
        writer.append("}\n\n");

        // If there are multiple groups then we will need to generate a function
        // for each
        boolean hasGroups = global.getCommandGroups().size() > 1 || global.getDefaultGroupCommands().size() == 0;
        if (hasGroups) {
            // TODO Generate group completion functions
        } else {
            for (CommandMetadata command : global.getDefaultGroupCommands()) {
                generateCommandCompletionFunction(writer, global, command);
            }
        }

        // Main command completion function
        writer.append("_complete_").append(bashize(global.getName())).append(" {").append('\n');

        writer.append("  # Get completion data").append('\n');
        writer.append("  COMPREPLY=()").append('\n');
        writer.append("  CURR_WORD=${COMP_WORDS[COMP_CWORD]}").append('\n');
        writer.append("  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}").append('\n');
        writer.append("  CURR_CMD=").append('\n');
        writer.append("  if [[ ${COMP_CWORD} -ge 1 ]]; then").append('\n');
        writer.append("    CURR_CMD=${COMP_WORDS[1]}").append('\n');
        writer.append("  fi").append("\n\n");

        // Prepare list of top level commands and groups
        Set<String> commandNames = new HashSet<>();
        for (CommandMetadata command : global.getDefaultGroupCommands()) {
            commandNames.add(command.getName());
        }
        if (hasGroups) {
            for (CommandGroupMetadata group : global.getCommandGroups()) {
                commandNames.add(group.getName());
            }
        }
        writeWordListVariable(writer, 2, "COMMANDS", commandNames.iterator());

        // Firstly check whether we are only completing the group or command
        writer.append("  if [[ ${COMP_CWORD} -eq 1 ]]; then").append('\n');
        writeCompletionGeneration(writer, 4, CompletionOptions.NONE, "COMMANDS");
        writer.append("  fi");

        // Otherwise we must be in a specific group/command
        // Use a switch statement to provide group/command specific completion
        writer.append("  case ${CURR_CMD} in ");
        if (hasGroups) {
            for (CommandGroupMetadata group : global.getCommandGroups()) {
                // Add case for the group
                indent(writer, 4);
                writer.append(group.getName()).append(')').append('\n');
                indent(writer, 6);

                // Just call the group function and pass its value back up
                writer.append("$( _completion_group_").append(bashize(group.getName())).append(" )").append('\n');
                indent(writer, 6);
                writer.append("return $?").append('\n');
                indent(writer, 6);
                writer.append(";;");
            }
        } else {
            for (CommandMetadata command : global.getDefaultGroupCommands()) {
                // Add case for the command
                indent(writer, 4);
                writer.append(command.getName()).append(')').append('\n');
                indent(writer, 6);

                // Just call the command function and pass its value back up
                writer.append("$( _completion_command_").append(bashize(command.getName())).append(" )").append('\n');
                indent(writer, 6);
                writer.append("return $?").append('\n');
                indent(writer, 6);
                writer.append(";;");
            }
        }

        writer.append("  esac").append("\n\n");

        writer.append("}").append("\n\n");

        // Completion setup
        writer.append("complete -F _complete_").append(bashize(global.getName())).append(" ").append(global.getName());

        // Flush the output
        writer.flush();
        output.flush();
    }

    private void generateCommandCompletionFunction(Writer writer, GlobalMetadata global, CommandMetadata command)
            throws IOException {
        writer.append("_completion_command_").append(bashize(command.getName())).append('{').append('\n');

        // Prepare variables
        writer.append("  # Get completion data").append('\n');
        writer.append("  COMPREPLY=()").append('\n');
        writer.append("  CURR_WORD=${COMP_WORDS[COMP_CWORD]}").append('\n');
        writer.append("  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}").append("\n");

        // Prepare the option information
        Set<String> flagOpts = new HashSet<>();
        Set<String> argOpts = new HashSet<>();
        for (OptionMetadata option : command.getAllOptions()) {
            if (option.getArity() == 0) {
                flagOpts.addAll(option.getOptions());
            } else {
                argOpts.addAll(option.getOptions());
            }
        }
        writeWordListVariable(writer, 2, "FLAG_OPTS", flagOpts.iterator());
        writeWordListVariable(writer, 2, "ARG_OPTS", argOpts.iterator());
        writer.append('\n');

        // Check whether we have a flag/arg option currently
        writer.append("  $( containsElement ${PREV_WORD} ${FLAG_OPTS[@]} )").append('\n');
        writer.append("  SAW_FLAG=$?").append('\n');
        writer.append("  $( containsElement ${PREV_WORD} ${ARG_OPTS[@]} )").append('\n');
        writer.append("  SAW_ARG=$?").append('\n');
        
        // If we previously saw an argument then we are completing that argument
        writer.append("  if [[ ${SAW_ARG} -eq 0 ]]; then").append('\n');
        // TODO Use a switch to populate completions for the argument options
        
        // If we previously saw a flag we could see another option or an argument if supported
        writer.append("  elif [[ ${SAW_FLAG} -eq 0 ]]; then").append('\n');
        
    }

    private void indent(Writer writer, int indent) throws IOException {
        repeat(writer, indent, ' ');
    }

    private void repeat(Writer writer, int count, char c) throws IOException {
        if (count <= 0)
            return;
        for (int i = 0; i < count; i++) {
            writer.append(c);
        }
    }

    private void writeWordListVariable(Writer writer, int indent, String varName, Iterator<String> words)
            throws IOException {
        indent(writer, indent);
        writer.append(varName).append("=\"");
        while (words.hasNext()) {
            writer.append(words.next());
            if (words.hasNext())
                writer.append(' ');
        }
        writer.append('"').append('\n');
    }

    private void writeCompletionGeneration(Writer writer, int indent, int behaviour, String... varNames)
            throws IOException {
        indent(writer, indent);
        writer.append("COMPREPLY=( $(compgen");

        // Add -o flag as appropriate
        switch (behaviour) {
        case CompletionOptions.FILENAMES:
            writer.append(" -o default ");
            break;
        case CompletionOptions.DIRECTORIES:
            writer.append(" -o dirnames ");
            break;
        case CompletionOptions.AS_FILENAMES:
            writer.append(" -o filenames ");
            break;
        case CompletionOptions.AS_DIRECTORIES:
            writer.append(" -o plusdirs ");
            break;
        }

        writer.append("-W \"");
        for (int i = 0; i < varNames.length; i++) {
            writer.append("${").append(varNames[i]).append("}");
            if (i < varNames.length - 1)
                writer.append(' ');
        }
        writer.append("\" -- ${CURR_WORD}) )").append('\n');
        indent(writer, indent);
        writer.append("return 0").append('\n');
    }

    private String bashize(String value) {
        StringBuilder builder = new StringBuilder();
        for (char c : value.toCharArray()) {
            if (Character.isLetterOrDigit(c) || c == '_') {
                builder.append(c);
            }
        }
        return builder.toString();
    }

}
